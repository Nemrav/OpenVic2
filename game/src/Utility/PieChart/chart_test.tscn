[gd_scene load_steps=16 format=3 uid="uid://ddns6vjdxq4t"]

[ext_resource type="Script" path="res://src/Utility/PieChart/chart_test.gd" id="1_o07pg"]
[ext_resource type="PackedScene" uid="uid://crhqik1qoon22" path="res://src/Utility/PieChart/layered_chart.tscn" id="2_4ptnh"]
[ext_resource type="PackedScene" uid="uid://d1ovecukckt5c" path="res://src/Utility/PieChart/PieChart.tscn" id="2_il0dq"]

[sub_resource type="Shader" id="Shader_k0lye"]
code = "shader_type canvas_item;

// The center in UV coordinates, which will always
//be 0.5, the actual radius will be controlled by the control node
//const vec2 center = vec2(0.5,0.5);
uniform float radius = 0.4;

//shadow
uniform vec2 shadow_displacement = vec2(0.75,0.75);
uniform float shadow_tightness = 10;
uniform float shadow_radius = 0.7;
uniform float shadow_thickness = 1.0;

// Control of the slices
uniform float stopAngles[5];
uniform vec3 colours[5];

// Trim
uniform vec3 trim_colour;
uniform float trim_size = 0.05;

// The center is spotlighted by the gradient,
//control its size and falloff with these
uniform float gradient_falloff = 3.6;
uniform float gradient_base = 3.1;

// control whether this is a donut instead of a pie chart
uniform bool donut = false;
uniform bool donut_inner_trim = false;
uniform float donut_inner_radius = 0.15;

// get the polar coordinates of a pixel relative to the center
vec2 getPolar(vec2 UVin, vec2 center){
	vec2 relcoord = (UVin-center);
	float dist = length(relcoord);
	float theta = PI/2.0 + atan((relcoord.y)/(relcoord.x));
	if(UVin.x < 0.5){
		theta += PI;
	}
	return vec2(dist,theta);
}

// from thebookofshaders, returns a gradient falloff
float parabola( float base, float x, float k ){
    return pow( base*x*(1.0-x), k );
}

float parabola_shadow(float base, float x){
	return base*x*x;
}

void fragment() {
	vec2 coords = getPolar(UV,vec2(0.5,0.5));
	float dist = coords.x;
	float theta = coords.y;

	vec2 shadow_polar = getPolar(UV,vec2(0.0+shadow_displacement.x,0.0+shadow_displacement.y));
	float shadow_peak = radius+(radius-donut_inner_radius)/2.0;
	float shadow_gradient = shadow_thickness+parabola_shadow(shadow_tightness*-10.0,shadow_polar.x+shadow_peak-shadow_radius);
	
	// inner hole of the donut => make it transparent
	if(donut && dist <= donut_inner_radius){
		COLOR = vec4(0.1,0.1,0.1,shadow_gradient);
	}
	// inner trim
	else if(donut && donut_inner_trim && dist <= donut_inner_radius + trim_size){
		COLOR = vec4(trim_colour,1.0);
	}
	// interior
	else if(dist <= radius-trim_size){ 
		for(int i=0;i<stopAngles.length();i++){
			if(theta <= stopAngles[i]){
				float gradient = parabola(gradient_base,dist,gradient_falloff);
				COLOR = vec4(colours[i]*(1.0-gradient),1.0);
				break;
			}
		}
	}
	// outer trim
	else if(dist <= radius){ 
		COLOR = vec4(trim_colour,1.0);
	}
	//outside the circle
	else{
		COLOR = vec4(0.1,0.1,0.1,shadow_gradient);
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_m6euf"]
resource_name = "Piechart_shader"
shader = SubResource("Shader_k0lye")
shader_parameter/radius = 0.367
shader_parameter/shadow_displacement = Vector2(0.535, 0.535)
shader_parameter/shadow_tightness = 8.0
shader_parameter/shadow_radius = 0.6
shader_parameter/shadow_thickness = 4.0
shader_parameter/stopAngles = [3.14159, 5.02655, 6.28319]
shader_parameter/colours = [Vector3(0, 0, 1), Vector3(1, 1, 0), Vector3(0.4, 0, 0.6)]
shader_parameter/trim_colour = Vector3(0, 0, 0)
shader_parameter/trim_size = 0.02
shader_parameter/gradient_falloff = 3.6
shader_parameter/gradient_base = 3.1
shader_parameter/donut = false
shader_parameter/donut_inner_trim = true
shader_parameter/donut_inner_radius = 0.1915

[sub_resource type="CanvasTexture" id="CanvasTexture_04ur3"]

[sub_resource type="Shader" id="Shader_lisaj"]
code = "shader_type canvas_item;

// The center in UV coordinates, which will always
//be 0.5, the actual radius will be controlled by the control node
//const vec2 center = vec2(0.5,0.5);
uniform float radius = 0.4;

//shadow
uniform vec2 shadow_displacement = vec2(0.75,0.75);
uniform float shadow_tightness = 10;
uniform float shadow_radius = 0.7;
uniform float shadow_thickness = 1.0;

// Control of the slices
uniform float stopAngles[5];
uniform vec3 colours[5];

// Trim
uniform vec3 trim_colour;
uniform float trim_size = 0.05;

// The center is spotlighted by the gradient,
//control its size and falloff with these
uniform float gradient_falloff = 3.6;
uniform float gradient_base = 3.1;

// control whether this is a donut instead of a pie chart
uniform bool donut = false;
uniform bool donut_inner_trim = false;
uniform float donut_inner_radius = 0.15;

// get the polar coordinates of a pixel relative to the center
vec2 getPolar(vec2 UVin, vec2 center){
	vec2 relcoord = (UVin-center);
	float dist = length(relcoord);
	float theta = PI/2.0 + atan((relcoord.y)/(relcoord.x));
	if(UVin.x < 0.5){
		theta += PI;
	}
	return vec2(dist,theta);
}

// from thebookofshaders, returns a gradient falloff
float parabola( float base, float x, float k ){
    return pow( base*x*(1.0-x), k );
}

float parabola_shadow(float base, float x){
	return base*x*x;
}

void fragment() {
	vec2 coords = getPolar(UV,vec2(0.5,0.5));
	float dist = coords.x;
	float theta = coords.y;

	vec2 shadow_polar = getPolar(UV,vec2(0.0+shadow_displacement.x,0.0+shadow_displacement.y));
	float shadow_peak = radius+(radius-donut_inner_radius)/2.0;
	float shadow_gradient = shadow_thickness+parabola_shadow(shadow_tightness*-10.0,shadow_polar.x+shadow_peak-shadow_radius);
	
	// inner hole of the donut => make it transparent
	if(donut && dist <= donut_inner_radius){
		COLOR = vec4(0.1,0.1,0.1,shadow_gradient);
	}
	// inner trim
	else if(donut && donut_inner_trim && dist <= donut_inner_radius + trim_size){
		COLOR = vec4(trim_colour,1.0);
	}
	// interior
	else if(dist <= radius-trim_size){ 
		for(int i=0;i<stopAngles.length();i++){
			if(theta <= stopAngles[i]){
				float gradient = parabola(gradient_base,dist,gradient_falloff);
				COLOR = vec4(colours[i]*(1.0-gradient),1.0);
				break;
			}
		}
	}
	// outer trim
	else if(dist <= radius){ 
		COLOR = vec4(trim_colour,1.0);
	}
	//outside the circle
	else{
		COLOR = vec4(0.1,0.1,0.1,shadow_gradient);
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_lt7hh"]
resource_name = "Piechart_shader"
shader = SubResource("Shader_lisaj")
shader_parameter/radius = 0.367
shader_parameter/shadow_displacement = Vector2(0.525, 0.525)
shader_parameter/shadow_tightness = 9.0
shader_parameter/shadow_radius = 0.58
shader_parameter/shadow_thickness = 5.3
shader_parameter/stopAngles = [3.14159, 5.02655, 6.28319]
shader_parameter/colours = [Vector3(0, 0, 1), Vector3(1, 1, 0), Vector3(0.4, 0, 0.6)]
shader_parameter/trim_colour = Vector3(0, 0, 0)
shader_parameter/trim_size = 0.02
shader_parameter/gradient_falloff = 3.6
shader_parameter/gradient_base = 3.1
shader_parameter/donut = false
shader_parameter/donut_inner_trim = true
shader_parameter/donut_inner_radius = 0.1915

[sub_resource type="CanvasTexture" id="CanvasTexture_byc0x"]

[sub_resource type="Shader" id="Shader_qesan"]
code = "shader_type canvas_item;

// The center in UV coordinates, which will always
//be 0.5, the actual radius will be controlled by the control node
//const vec2 center = vec2(0.5,0.5);
uniform float radius = 0.4;

//shadow
uniform vec2 shadow_displacement = vec2(0.75,0.75);
uniform float shadow_tightness = 10;
uniform float shadow_radius = 0.7;
uniform float shadow_thickness = 1.0;

// Control of the slices
uniform float stopAngles[5];
uniform vec3 colours[5];

// Trim
uniform vec3 trim_colour;
uniform float trim_size = 0.05;

// The center is spotlighted by the gradient,
//control its size and falloff with these
uniform float gradient_falloff = 3.6;
uniform float gradient_base = 3.1;

// control whether this is a donut instead of a pie chart
uniform bool donut = false;
uniform bool donut_inner_trim = false;
uniform float donut_inner_radius = 0.15;

// get the polar coordinates of a pixel relative to the center
vec2 getPolar(vec2 UVin, vec2 center){
	vec2 relcoord = (UVin-center);
	float dist = length(relcoord);
	float theta = PI/2.0 + atan((relcoord.y)/(relcoord.x));
	if(UVin.x < 0.5){
		theta += PI;
	}
	return vec2(dist,theta);
}

// from thebookofshaders, returns a gradient falloff
float parabola( float base, float x, float k ){
    return pow( base*x*(1.0-x), k );
}

float parabola_shadow(float base, float x){
	return base*x*x;
}

void fragment() {
	vec2 coords = getPolar(UV,vec2(0.5,0.5));
	float dist = coords.x;
	float theta = coords.y;

	vec2 shadow_polar = getPolar(UV,vec2(0.0+shadow_displacement.x,0.0+shadow_displacement.y));
	float shadow_peak = radius+(radius-donut_inner_radius)/2.0;
	float shadow_gradient = shadow_thickness+parabola_shadow(shadow_tightness*-10.0,shadow_polar.x+shadow_peak-shadow_radius);
	
	// inner hole of the donut => make it transparent
	if(donut && dist <= donut_inner_radius){
		COLOR = vec4(0.1,0.1,0.1,shadow_gradient);
	}
	// inner trim
	else if(donut && donut_inner_trim && dist <= donut_inner_radius + trim_size){
		COLOR = vec4(trim_colour,1.0);
	}
	// interior
	else if(dist <= radius-trim_size){ 
		for(int i=0;i<stopAngles.length();i++){
			if(theta <= stopAngles[i]){
				float gradient = parabola(gradient_base,dist,gradient_falloff);
				COLOR = vec4(colours[i]*(1.0-gradient),1.0);
				break;
			}
		}
	}
	// outer trim
	else if(dist <= radius){ 
		COLOR = vec4(trim_colour,1.0);
	}
	//outside the circle
	else{
		COLOR = vec4(0.1,0.1,0.1,shadow_gradient);
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_caya7"]
resource_name = "Piechart_shader"
shader = SubResource("Shader_qesan")
shader_parameter/radius = 0.367
shader_parameter/shadow_displacement = Vector2(0.535, 0.535)
shader_parameter/shadow_tightness = 10.0
shader_parameter/shadow_radius = 0.592
shader_parameter/shadow_thickness = 5.3
shader_parameter/stopAngles = [3.14159, 5.02655, 6.28319]
shader_parameter/colours = [Vector3(0, 0, 1), Vector3(1, 1, 0), Vector3(0.4, 0, 0.6)]
shader_parameter/trim_colour = Vector3(0, 0, 0)
shader_parameter/trim_size = 0.02
shader_parameter/gradient_falloff = 3.6
shader_parameter/gradient_base = 3.1
shader_parameter/donut = false
shader_parameter/donut_inner_trim = true
shader_parameter/donut_inner_radius = 0.1915

[sub_resource type="CanvasTexture" id="CanvasTexture_vsdkn"]

[sub_resource type="Shader" id="Shader_8j8mp"]
code = "shader_type canvas_item;

// The center in UV coordinates, which will always
//be 0.5, the actual radius will be controlled by the control node
//const vec2 center = vec2(0.5,0.5);
uniform float radius = 0.4;

//shadow
uniform vec2 shadow_displacement = vec2(0.75,0.75);
uniform float shadow_tightness = 10;
uniform float shadow_radius = 0.7;
uniform float shadow_thickness = 1.0;

// Control of the slices
uniform float stopAngles[5];
uniform vec3 colours[5];

// Trim
uniform vec3 trim_colour;
uniform float trim_size = 0.05;

// The center is spotlighted by the gradient,
//control its size and falloff with these
uniform float gradient_falloff = 3.6;
uniform float gradient_base = 3.1;

// control whether this is a donut instead of a pie chart
uniform bool donut = false;
uniform bool donut_inner_trim = false;
uniform float donut_inner_radius = 0.15;

// get the polar coordinates of a pixel relative to the center
vec2 getPolar(vec2 UVin, vec2 center){
	vec2 relcoord = (UVin-center);
	float dist = length(relcoord);
	float theta = PI/2.0 + atan((relcoord.y)/(relcoord.x));
	if(UVin.x < 0.5){
		theta += PI;
	}
	return vec2(dist,theta);
}

// from thebookofshaders, returns a gradient falloff
float parabola( float base, float x, float k ){
    return pow( base*x*(1.0-x), k );
}

float parabola_shadow(float base, float x){
	return base*x*x;
}

void fragment() {
	vec2 coords = getPolar(UV,vec2(0.5,0.5));
	float dist = coords.x;
	float theta = coords.y;

	vec2 shadow_polar = getPolar(UV,vec2(0.0+shadow_displacement.x,0.0+shadow_displacement.y));
	float shadow_peak = radius+(radius-donut_inner_radius)/2.0;
	float shadow_gradient = shadow_thickness+parabola_shadow(shadow_tightness*-10.0,shadow_polar.x+shadow_peak-shadow_radius);
	
	// inner hole of the donut => make it transparent
	if(donut && dist <= donut_inner_radius){
		COLOR = vec4(0.1,0.1,0.1,shadow_gradient);
	}
	// inner trim
	else if(donut && donut_inner_trim && dist <= donut_inner_radius + trim_size){
		COLOR = vec4(trim_colour,1.0);
	}
	// interior
	else if(dist <= radius-trim_size){ 
		for(int i=0;i<stopAngles.length();i++){
			if(theta <= stopAngles[i]){
				float gradient = parabola(gradient_base,dist,gradient_falloff);
				COLOR = vec4(colours[i]*(1.0-gradient),1.0);
				break;
			}
		}
	}
	// outer trim
	else if(dist <= radius){ 
		COLOR = vec4(trim_colour,1.0);
	}
	//outside the circle
	else{
		COLOR = vec4(0.1,0.1,0.1,shadow_gradient);
	}
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_rqgnb"]
resource_name = "Piechart_shader"
shader = SubResource("Shader_8j8mp")
shader_parameter/radius = 0.367
shader_parameter/shadow_displacement = Vector2(0.54, 0.54)
shader_parameter/shadow_tightness = 8.901
shader_parameter/shadow_radius = 0.72
shader_parameter/shadow_thickness = 1.0
shader_parameter/stopAngles = [3.14159, 5.02655, 6.28319]
shader_parameter/colours = [Vector3(0, 0, 1), Vector3(1, 1, 0), Vector3(0.4, 0, 0.6)]
shader_parameter/trim_colour = Vector3(0, 0, 0)
shader_parameter/trim_size = 0.02
shader_parameter/gradient_falloff = 3.6
shader_parameter/gradient_base = 3.1
shader_parameter/donut = true
shader_parameter/donut_inner_trim = true
shader_parameter/donut_inner_radius = 0.1915

[sub_resource type="CanvasTexture" id="CanvasTexture_r1llf"]

[node name="chart_test" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_o07pg")

[node name="PieChart3" parent="." instance=ExtResource("2_il0dq")]
material = SubResource("ShaderMaterial_m6euf")
layout_mode = 0
offset_left = 108.0
offset_top = 5.0
offset_right = 188.0
offset_bottom = 85.0
texture = SubResource("CanvasTexture_04ur3")
shadow_focus = 8.0
shadow_radius = 0.6
shadow_thickness = 4.0

[node name="PieChart4" parent="." instance=ExtResource("2_il0dq")]
material = SubResource("ShaderMaterial_lt7hh")
layout_mode = 0
offset_left = 158.0
offset_top = 81.0
offset_right = 278.0
offset_bottom = 201.0
texture = SubResource("CanvasTexture_byc0x")
shadow_displacement = Vector2(0.525, 0.525)
shadow_focus = 9.0
shadow_radius = 0.58

[node name="PieChart5" parent="." instance=ExtResource("2_il0dq")]
material = SubResource("ShaderMaterial_caya7")
layout_mode = 0
offset_left = 81.0
offset_top = 181.0
offset_right = 131.0
offset_bottom = 231.0
texture = SubResource("CanvasTexture_vsdkn")

[node name="Donut" parent="." instance=ExtResource("2_il0dq")]
material = SubResource("ShaderMaterial_rqgnb")
layout_mode = 0
offset_left = 284.0
offset_top = 13.0
offset_right = 364.0
offset_bottom = 93.0
texture = SubResource("CanvasTexture_r1llf")
donut = true
shadow_displacement = Vector2(0.54, 0.54)
shadow_focus = 8.901
shadow_radius = 0.72
shadow_thickness = 1.0

[node name="LayeredChart" parent="." instance=ExtResource("2_4ptnh")]
layout_mode = 0
offset_left = 55.0
offset_top = 86.0
offset_right = 105.0
offset_bottom = 136.0
