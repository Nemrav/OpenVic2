[gd_scene load_steps=12 format=3 uid="uid://ddns6vjdxq4t"]

[ext_resource type="Script" path="res://src/Utility/PieChart/chart_test.gd" id="1_o07pg"]
[ext_resource type="Script" path="res://src/Utility/PieChart/PieChart.gd" id="2_ed73j"]

[sub_resource type="Shader" id="Shader_63w1h"]
code = "shader_type canvas_item;

//The center in UV coordinates, which will always
//be 0.5, the actual radius will be controlled by the control node
const vec2 center = vec2(0.5,0.5);
const float radius = 0.5;

//Control of the slices
uniform float stopAngles[5];
uniform vec3 colours[5];

//Trim
uniform vec3 trim_colour;
uniform float trim_size = 0.05;

//The center is spotlighted by the gradient,
// control its size and falloff with these
uniform float gradient_falloff = 3.6;
uniform float gradient_base = 3.1;

//control whether this is a donut instead of a pie chart
uniform bool donut = false;
uniform bool donut_inner_trim = false;
uniform float donut_inner_radius = 0.15;

//get the polar coordinates of a pixel relative to the center
vec2 getPolar(vec2 UVin){
	vec2 relcoord = (UVin-center);
	float dist = length(relcoord);
	float theta = PI/2.0 + atan((relcoord.y)/(relcoord.x));
	if(UVin.x < 0.5){
		theta += PI;
	}
	return vec2(dist,theta);
}

//from thebookofshaders, returns a gradient falloff
float parabola( float x, float k ){
    return pow( gradient_base*x*(1.0-x), k );
}

void fragment() {
	vec2 coords = getPolar(UV);
	float dist = coords.x;
	float theta = coords.y;
	//inner hole of the donut => make it trasparent
	if(donut && dist <= donut_inner_radius){
		COLOR = vec4(0.0,0.0,0.0,0.0);
	}
	//inner trim
	else if(donut && donut_inner_trim && dist <= donut_inner_radius + trim_size){
		COLOR = vec4(trim_colour,1.0);
	}
	//interior
	else if(dist <= radius-trim_size){ 
		for(int i=0;i<stopAngles.length();i++){
			if(theta <= stopAngles[i]){
				float gradient = parabola(dist,gradient_falloff);
				COLOR = vec4(colours[i]*(1.0-gradient),1.0);
				break;
			}
		}
	}
	//outer trim
	else if(dist <= radius){ 
		COLOR = vec4(trim_colour,1.0);
	}
	//outside the circle => make it transparent
	else { 
		COLOR = vec4(0.0,0.0,0.0,0.0);
	}
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_2pxuj"]
resource_name = "Piechart_shader"
shader = SubResource("Shader_63w1h")
shader_parameter/stopAngles = [3.14159, 5.02655, 6.28319]
shader_parameter/colours = [Vector3(0, 0, 1), Vector3(1, 1, 0), Vector3(0.4, 0, 0.6)]
shader_parameter/trim_colour = null
shader_parameter/trim_size = 0.021
shader_parameter/gradient_falloff = 3.6
shader_parameter/gradient_base = 3.1
shader_parameter/donut = false
shader_parameter/donut_inner_trim = true
shader_parameter/donut_inner_radius = 0.25

[sub_resource type="CanvasTexture" id="CanvasTexture_16clm"]

[sub_resource type="Shader" id="Shader_p7a4d"]
code = "shader_type canvas_item;

//The center in UV coordinates, which will always
//be 0.5, the actual radius will be controlled by the control node
const vec2 center = vec2(0.5,0.5);
const float radius = 0.5;

//Control of the slices
uniform float stopAngles[5];
uniform vec3 colours[5];

//Trim
uniform vec3 trim_colour;
uniform float trim_size = 0.05;

//The center is spotlighted by the gradient,
// control its size and falloff with these
uniform float gradient_falloff = 3.6;
uniform float gradient_base = 3.1;

//control whether this is a donut instead of a pie chart
uniform bool donut = false;
uniform bool donut_inner_trim = false;
uniform float donut_inner_radius = 0.15;

//get the polar coordinates of a pixel relative to the center
vec2 getPolar(vec2 UVin){
	vec2 relcoord = (UVin-center);
	float dist = length(relcoord);
	float theta = PI/2.0 + atan((relcoord.y)/(relcoord.x));
	if(UVin.x < 0.5){
		theta += PI;
	}
	return vec2(dist,theta);
}

//from thebookofshaders, returns a gradient falloff
float parabola( float x, float k ){
    return pow( gradient_base*x*(1.0-x), k );
}

void fragment() {
	vec2 coords = getPolar(UV);
	float dist = coords.x;
	float theta = coords.y;
	//inner hole of the donut => make it trasparent
	if(donut && dist <= donut_inner_radius){
		COLOR = vec4(0.0,0.0,0.0,0.0);
	}
	//inner trim
	else if(donut && donut_inner_trim && dist <= donut_inner_radius + trim_size){
		COLOR = vec4(trim_colour,1.0);
	}
	//interior
	else if(dist <= radius-trim_size){ 
		for(int i=0;i<stopAngles.length();i++){
			if(theta <= stopAngles[i]){
				float gradient = parabola(dist,gradient_falloff);
				COLOR = vec4(colours[i]*(1.0-gradient),1.0);
				break;
			}
		}
	}
	//outer trim
	else if(dist <= radius){ 
		COLOR = vec4(trim_colour,1.0);
	}
	//outside the circle => make it transparent
	else { 
		COLOR = vec4(0.0,0.0,0.0,0.0);
	}
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_40tfd"]
resource_name = "Piechart_shader"
shader = SubResource("Shader_p7a4d")
shader_parameter/stopAngles = [3.14159, 5.02655, 6.28319]
shader_parameter/colours = [Vector3(0, 0, 1), Vector3(1, 1, 0), Vector3(0.4, 0, 0.6)]
shader_parameter/trim_colour = null
shader_parameter/trim_size = 0.021
shader_parameter/gradient_falloff = 3.6
shader_parameter/gradient_base = 3.1
shader_parameter/donut = true
shader_parameter/donut_inner_trim = true
shader_parameter/donut_inner_radius = 0.18

[sub_resource type="CanvasTexture" id="CanvasTexture_6rmsm"]

[sub_resource type="Shader" id="Shader_apbll"]
code = "shader_type canvas_item;

//The center in UV coordinates, which will always
//be 0.5, the actual radius will be controlled by the control node
const vec2 center = vec2(0.5,0.5);
const float radius = 0.5;

//Control of the slices
uniform float stopAngles[5];
uniform vec3 colours[5];

//Trim
uniform vec3 trim_colour;
uniform float trim_size = 0.05;

//The center is spotlighted by the gradient,
// control its size and falloff with these
uniform float gradient_falloff = 3.6;
uniform float gradient_base = 3.1;

//control whether this is a donut instead of a pie chart
uniform bool donut = false;
uniform bool donut_inner_trim = false;
uniform float donut_inner_radius = 0.15;

//get the polar coordinates of a pixel relative to the center
vec2 getPolar(vec2 UVin){
	vec2 relcoord = (UVin-center);
	float dist = length(relcoord);
	float theta = PI/2.0 + atan((relcoord.y)/(relcoord.x));
	if(UVin.x < 0.5){
		theta += PI;
	}
	return vec2(dist,theta);
}

//from thebookofshaders, returns a gradient falloff
float parabola( float x, float k ){
    return pow( gradient_base*x*(1.0-x), k );
}

void fragment() {
	vec2 coords = getPolar(UV);
	float dist = coords.x;
	float theta = coords.y;
	//inner hole of the donut => make it trasparent
	if(donut && dist <= donut_inner_radius){
		COLOR = vec4(0.0,0.0,0.0,0.0);
	}
	//inner trim
	else if(donut && donut_inner_trim && dist <= donut_inner_radius + trim_size){
		COLOR = vec4(trim_colour,1.0);
	}
	//interior
	else if(dist <= radius-trim_size){ 
		for(int i=0;i<stopAngles.length();i++){
			if(theta <= stopAngles[i]){
				float gradient = parabola(dist,gradient_falloff);
				COLOR = vec4(colours[i]*(1.0-gradient),1.0);
				break;
			}
		}
	}
	//outer trim
	else if(dist <= radius){ 
		COLOR = vec4(trim_colour,1.0);
	}
	//outside the circle => make it transparent
	else { 
		COLOR = vec4(0.0,0.0,0.0,0.0);
	}
	
}"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_p20v2"]
resource_name = "Piechart_shader"
shader = SubResource("Shader_apbll")
shader_parameter/stopAngles = [3.14159, 5.02655, 6.28319]
shader_parameter/colours = [Vector3(0, 0, 1), Vector3(1, 1, 0), Vector3(0.4, 0, 0.6)]
shader_parameter/trim_colour = null
shader_parameter/trim_size = 0.021
shader_parameter/gradient_falloff = 3.6
shader_parameter/gradient_base = 3.1
shader_parameter/donut = false
shader_parameter/donut_inner_trim = true
shader_parameter/donut_inner_radius = 0.25

[sub_resource type="CanvasTexture" id="CanvasTexture_6l56f"]

[node name="chart_test" type="Control"]
layout_mode = 3
anchors_preset = 15
anchor_right = 1.0
anchor_bottom = 1.0
grow_horizontal = 2
grow_vertical = 2
script = ExtResource("1_o07pg")

[node name="PieChart3" type="TextureRect" parent="."]
material = SubResource("ShaderMaterial_2pxuj")
custom_minimum_size = Vector2(50, 50)
layout_mode = 0
offset_right = 50.0
offset_bottom = 50.0
size_flags_horizontal = 4
size_flags_vertical = 4
texture = SubResource("CanvasTexture_16clm")
script = ExtResource("2_ed73j")

[node name="PieChart" type="TextureRect" parent="."]
material = SubResource("ShaderMaterial_40tfd")
custom_minimum_size = Vector2(50, 50)
layout_mode = 0
offset_right = 50.0
offset_bottom = 50.0
size_flags_horizontal = 4
size_flags_vertical = 4
texture = SubResource("CanvasTexture_6rmsm")
script = ExtResource("2_ed73j")
donut = true
donut_inner_radius = 0.36

[node name="PieChart2" type="TextureRect" parent="."]
material = SubResource("ShaderMaterial_p20v2")
custom_minimum_size = Vector2(50, 50)
layout_mode = 0
offset_left = 59.0
offset_right = 129.0
offset_bottom = 70.0
size_flags_horizontal = 4
size_flags_vertical = 4
texture = SubResource("CanvasTexture_6l56f")
script = ExtResource("2_ed73j")
